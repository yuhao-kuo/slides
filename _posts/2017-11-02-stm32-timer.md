---
layout: slide
title: "stm32 interrupt"
img: image-5.png
description: "stm32 中斷和timer教學, 這個教學不會告訴你完整的程式, 需要完整的程式請直接上到雲端去下載範例檔"
---

# STM32 interrupt

Timer and NVIC

> **wheel robot lab** 2017.

---

## 章節重點

* 本章節將使用 `Timer3` 來做為中斷計數器
* `Timer3` 每 **10ms** 產生一次中斷
* ARM Crotex-M 系列特有的 `NVIC` 中斷管理單元

---

## Interrupt 中斷

----

#### 圖片

----

從上一頁我們可以知道

看電視是原本所做的事情

電話響了就是所謂的中斷

而講電話就是中斷服務流程

**`(Interrupt Service Routine (ISR))`**

----

## 淺談中斷

----

### STM32中斷事件

1. 系統計時器
2. 記憶存取錯誤
3. 外部重置
4. 還有很多內建的硬體 USART, I2C, DMA

----

我們可以想像這些產生事件的信號是被核心在程式進行中不斷的被監控的，而當事件發生時，核心能對他做正確地處理

----

說得更細一點的話，核心會先將目前執行程式的計數器放入堆疊區，然後執行對應的ISR完畢後把原本的程式計數器放回來然後繼續原本的流程。

----

剛剛所講解的我們都不必去寫那些程式，因為那是ARM公司幫我們做好的部分，我們只要知道如何正確地設定這些中斷，之後就讓他自己執行就好了。

---

## NVIC

#### Nested Vectored Interrupt Controller

---

## 甚麼是NVIC

NVIC 是 ARM Crotex-M 中負責管理中斷事件的硬體控制器

----

## NVIC 功能

1. 中斷發生時 **stack** 的 `push` 和`pull` 操作
2. 管理中斷優先權

----

## 再論中斷

1. 多個中斷同時產生怎麼辦?
2. core正在處理ISR中斷事件時另一個中斷產生了!

----

#### 先想想幾個經典問題

1. **媽媽**和**女(男)朋友**同時掉進水裡, 只能先救一個的情況下, 你要救誰?
    * 務實一點, 先救不會游泳的
2. 燒開水滾了, 有人在按門鈴, 要先做那件事?
    * 當然先處理開水, 門外的人可以小等幾秒鐘

----

### 1. 多個中斷產生

----

當一堆中斷在那邊搶core資源

該怎麼解決 先打一打!?

----

就算要打架 也要有core資源才能互相傷害...

----

於是就有了優先權這個概念了

----

### 1. 多個中斷產生

----

`NVIC` 會根據優先權表來決定誰可以先做, 做完再做另一件事

----

所以會變這個概念

| 優先權 | 結果 |
|---|---|
| 比較大 | 先執行 |
| 比較小 | 等大的執行完 |

----

如果以程式的概念, 就是這樣!!

```clike=
if (A_ISR_Priority > B_ISR_Priority) {
    /* A優先權比較大 */
    run_A_ISR();    // 執行A
    run_B_ISR();    // 執行B
} else {
    /* B優先權比較大 */
    run_B_ISR();
    run_A_ISR();
}
```

----

### 2. 處理中斷事件時另一個中斷產生了

----

此時 `NVIC` 還是會比較優先權順序, 會有2種狀態

| 優先權 | 結果 |
|---|---|
| 較低 | 先執行**現在**的ISR |
| 較高 | 先執行**後來發生**的ISR |

----

所以 優先權小的可能會被一直被暫停!!

---

## Timer 計數器/計時器

----

## TIM Configuration

----

看看 datasheet 得知 `Timer3` 時脈來源是 **`ABP1`**
因此到 `f4-config.c` 中的**RCC_Configuration(void)** 加入

```clike
RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);
```

----

* 將`stm32f4xx_tim.c`
  加到`stm32f4xx_library`群組中

----

* 在main.h中加入TIMER副程式宣告:

```clike=
void TIM_TIM_Config(void);
```

----

* 在f4-config.c中加入

```clike=
void TIM_TIM_Config(void)
{
    
}
```

----

* 在stm32f4xx_tim.h第49行能得知TIM的資料結構定義TIM_TimeBaseInitTypeDef，程式中加入
	
```clike=
TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;
```

----

* 將TIM3重新初始化一次，加入

```clike=
TIM_DeInit(TIM3);
```

----

* TIM_TimeBaseInitTypeDef中的資料結構內容為TIM的設定，分為：
    1. TIM_Prescaler
    2. TIM_CounterMode
    3. TIM_Period
    4. TIM_ClockDivision
    5. TIM_RepetitionCounter

----

## TIM Configuration 名詞解釋

----

| 名字 | 型態 | 功能 |
|---|---|---|
| TIM_Prescaler | `uint16_t` | TIM時脈的預除器，將TIM時脈進行除頻 |
| TIM_CounterMode | `uint16_t` | 指定計數器模式 |
| TIM_Period | `uint32_t` | 指定計數器模式 |

----

| 名字 | 型態 | 功能 |
|---|---|---|
| TIM_ClockDivision | `uint16_t` | 指定時脈除頻 |
| TIM_RepetitionCounter | `uint8_t` | 指定重複計數器值 |

----

## 加入設定

----

```clike=
TIM_TimeBaseStructure.TIM_Prescaler = 83;
TIM_TimeBaseStructure.TIM_Period = 9999;	
TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1; 
TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
TIM_TimeBaseStructure.TIM_RepetitionCounter = 0; 
TIM_TimeBaseInit(TIM3, &TIM_TimeBaseStructure);
TIM_ClearFlag(TIM3, TIM_IT_Update);    
TIM_ITConfig(TIM3, TIM_IT_Update, ENABLE);            
TIM_Cmd(TIM3, ENABLE);	
```

----

## TIM3 補充說明

* 之前在設定TIM3為10ms中斷時得知TIM3時脈來源為APB1，APB1最大時脈頻率為42MHz而在設定時卻以84MHz為準

----

* 這是因為在APBx在提供timer時脈之前會經過一個內置倍頻器(internal PLL)，而倍頻器有兩種模式：

    | 預除器 | 倍率 |
    |---|---|
    | 1 | * 1 |
    | >1 | * n |

----

* 我們使用的AHB時脈為168MHz而在經過除頻器除以4之後得到42MHz的APB1，所以APB1提供給timer的時脈頻率就被內置倍頻器乘以2放大至84MHz

----

## TIM3 中斷執行程式

* 設定了中斷當然也要設定中斷時執行的程式，如清除中斷旗標或是讓變數的數值遞增或遞減以達到計數或是延遲等動作

* 中斷執行程式都聚集在stm32f4xx_it.c中，但是卻找不到任何有關TIM3中斷執行的部分，可透過startup_stm32f40_41xxx.s中尋找有關TIM3的中斷執行向量，在116行得知TIM3中斷向量為TIM3_IRQHandler

----

## TIM3 中斷執行程式

在stm32f4xx_it.c中加入

```clike=
void TIM3_IRQHandler(void)
{
    TIM_ClearITPendingBit(TIM3, TIM_FLAG_Update);
}
```

